<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SnapStranger</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f0f0f0;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background-color: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        h1 {
            text-align: center;
            color: #333;
            margin-bottom: 10px;
        }
        .subtitle {
            text-align: center;
            color: #666;
            margin-bottom: 30px;
        }
        .upload-area {
            border: 2px dashed #ccc;
            border-radius: 10px;
            padding: 40px;
            text-align: center;
            margin-bottom: 20px;
            cursor: pointer;
            transition: border-color 0.3s;
        }
        .upload-area:hover {
            border-color: #999;
        }
        .upload-area.dragover {
            border-color: #007bff;
            background-color: #f8f9fa;
        }
        #canvas-container {
            position: relative;
            display: none;
            text-align: center;
            margin-bottom: 20px;
        }
        #canvas {
            border: 1px solid #ddd;
            max-width: 100%;
            cursor: crosshair;
        }
        .controls {
            display: none;
            margin-top: 20px;
        }
        .mode-selector {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            justify-content: center;
            flex-wrap: wrap;
        }
        .mode-btn {
            padding: 10px 20px;
            border: 2px solid #ddd;
            border-radius: 5px;
            background-color: white;
            cursor: pointer;
            transition: all 0.3s;
        }
        .mode-btn.active {
            background-color: #007bff;
            color: white;
            border-color: #007bff;
        }
        .brush-controls, .emoji-controls {
            background-color: #f8f9fa;
            padding: 20px;
            border-radius: 5px;
            margin-bottom: 20px;
        }
        .emoji-controls {
            display: none;
        }
        .control-group {
            margin-bottom: 15px;
        }
        .control-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        }
        .control-group input[type="range"] {
            width: 100%;
            margin-bottom: 5px;
        }
        .color-palette {
            display: flex;
            gap: 5px;
            margin-top: 10px;
            flex-wrap: wrap;
        }
        .color-btn {
            width: 30px;
            height: 30px;
            border: 2px solid #ddd;
            border-radius: 50%;
            cursor: pointer;
            transition: transform 0.2s;
        }
        .color-btn.active {
            transform: scale(1.2);
            border-color: #333;
        }
        .emoji-selector {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
            flex-wrap: wrap;
        }
        .emoji-btn {
            font-size: 30px;
            padding: 10px;
            border: 2px solid #ddd;
            border-radius: 5px;
            background-color: white;
            cursor: pointer;
            transition: all 0.3s;
        }
        .emoji-btn.active {
            border-color: #007bff;
            background-color: #e7f3ff;
        }
        .layer-controls {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            justify-content: center;
            flex-wrap: wrap;
        }
        .layer-btn {
            padding: 8px 16px;
            border: 1px solid #ddd;
            border-radius: 5px;
            background-color: white;
            cursor: pointer;
            transition: all 0.3s;
        }
        .layer-btn.active {
            background-color: #28a745;
            color: white;
            border-color: #28a745;
        }
        .action-buttons {
            display: flex;
            gap: 10px;
            justify-content: center;
            flex-wrap: wrap;
            margin-top: 20px;
        }
        .btn {
            padding: 10px 20px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            transition: background-color 0.3s;
        }
        .btn-primary {
            background-color: #007bff;
            color: white;
        }
        .btn-primary:hover {
            background-color: #0056b3;
        }
        .btn-secondary {
            background-color: #6c757d;
            color: white;
        }
        .btn-secondary:hover {
            background-color: #545b62;
        }
        .btn-danger {
            background-color: #dc3545;
            color: white;
        }
        .btn-danger:hover {
            background-color: #c82333;
        }
        .brush-preview {
            width: 50px;
            height: 50px;
            border: 1px solid #ddd;
            border-radius: 50%;
            margin: 10px auto;
            background-color: #000;
        }
        .emoji-handle {
            position: absolute;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            cursor: pointer;
        }
        .resize-handle {
            background-color: #28a745;
            right: -4px;
            bottom: -4px;
            cursor: se-resize;
        }
        .rotate-handle {
            background-color: #ffc107;
            right: -4px;
            top: -4px;
            cursor: grab;
        }
        .delete-handle {
            background-color: #dc3545;
            left: -4px;
            top: -4px;
            cursor: pointer;
        }
        .delete-handle::after {
            content: 'Ã—';
            color: white;
            font-size: 6px;
            position: absolute;
            top: -1px;
            left: 1px;
        }
        @media (max-width: 768px) {
            .container {
                padding: 10px;
            }
            .mode-selector, .action-buttons, .layer-controls {
                flex-direction: column;
                align-items: center;
            }
            .color-palette, .emoji-selector {
                justify-content: center;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>SnapStranger</h1>
        <p class="subtitle">Street Photography: Strangers on Another Layer</p>
        <p class="subtitle">çŸ¥ã‚‰ãªã„ä»–äººã‚’åˆ¥ã®ãƒ¬ã‚¤ãƒ¤ãƒ¼ã«ç§»å‹•ã—ã¦ã‚‚ã‚‰ã†ã‚¹ãƒˆãƒªãƒ¼ãƒˆãƒ•ã‚©ãƒˆã‚°ãƒ©ãƒ•ã‚£ãƒ¼</p>
        <p class="subtitle">åˆ¶ä½œè€…: <a href="https://x.com/masakiishitani" target="_blank" style="color: #007bff; text-decoration: none;">@masakiishitani</a></p>
        <p class="subtitle" style="font-size: 0.9em; color: #666; margin-top: 10px;">ğŸ’» PCç’°å¢ƒã§ã®åˆ©ç”¨ã‚’æ¨å¥¨ã—ã¾ã™</p>
        
        <div class="concept-image">
            <img src="snapstranger-concept-monochrome.png" alt="SnapStranger Concept" style="max-width: 100%; height: auto; border-radius: 10px; margin: 20px 0;">
        </div>
        
        <div class="upload-area" id="uploadArea">
            <p>ç”»åƒã‚’ãƒ‰ãƒ©ãƒƒã‚°&ãƒ‰ãƒ­ãƒƒãƒ—ã™ã‚‹ã‹ã€ã‚¯ãƒªãƒƒã‚¯ã—ã¦ãƒ•ã‚¡ã‚¤ãƒ«ã‚’é¸æŠã—ã¦ãã ã•ã„</p>
            <input type="file" id="fileInput" accept="image/*">
        </div>
        
        <div id="canvas-container">
            <canvas id="canvas"></canvas>
        </div>
        
        <div class="controls" id="controls">
            <div class="mode-selector">
                <button class="mode-btn active" id="brushMode">ãƒ–ãƒ©ã‚·ãƒ¢ãƒ¼ãƒ‰</button>
                <button class="mode-btn" id="emojiMode">é¡”æ–‡å­—ãƒ¢ãƒ¼ãƒ‰</button>
            </div>
            
            <div class="layer-controls">
                <button class="layer-btn active" id="brushLayerToggle">ãƒ–ãƒ©ã‚·ãƒ¬ã‚¤ãƒ¤ãƒ¼è¡¨ç¤º</button>
                <button class="layer-btn active" id="emojiLayerToggle">é¡”æ–‡å­—ãƒ¬ã‚¤ãƒ¤ãƒ¼è¡¨ç¤º</button>
            </div>
            
            <div class="brush-controls" id="brushControls">
                <div class="control-group">
                    <label>ãƒ–ãƒ©ã‚·ã‚µã‚¤ã‚º: <span id="brushSizeValue">20</span>px</label>
                    <input type="range" id="brushSize" min="1" max="100" value="20">
                </div>
                <div class="control-group">
                    <label>ä¸é€æ˜åº¦: <span id="opacityValue">100</span>%</label>
                    <input type="range" id="opacity" min="1" max="100" value="100">
                </div>
                <div class="control-group">
                    <label>ãƒã‚¤ã‚ºè¿½åŠ : <span id="noiseValue">0</span>%</label>
                    <input type="range" id="noise" min="0" max="100" value="0">
                </div>
                <div class="control-group">
                    <label>ã‚¨ãƒƒã‚¸ã®ã¼ã‹ã—: <span id="blurValue">0</span>px</label>
                    <input type="range" id="blur" min="0" max="20" value="0">
                </div>
                <div class="control-group">
                    <label>ã‚«ãƒ©ãƒ¼ãƒ‘ãƒ¬ãƒƒãƒˆ:</label>
                    <div class="color-palette">
                        <div class="color-btn active" style="background-color: #000000" data-color="#000000"></div>
                        <div class="color-btn" style="background-color: #ffffff" data-color="#ffffff"></div>
                        <div class="color-btn" style="background-color: #ff0000" data-color="#ff0000"></div>
                        <div class="color-btn" style="background-color: #00ff00" data-color="#00ff00"></div>
                        <div class="color-btn" style="background-color: #0000ff" data-color="#0000ff"></div>
                        <div class="color-btn" style="background-color: #ffff00" data-color="#ffff00"></div>
                        <div class="color-btn" style="background-color: #800080" data-color="#800080"></div>
                        <div class="color-btn" style="background-color: #ffa500" data-color="#ffa500"></div>
                        <div class="color-btn" style="background-color: #808080" data-color="#808080"></div>
                    </div>
                </div>
                <div class="brush-preview" id="brushPreview"></div>
            </div>
            
            <div class="emoji-controls" id="emojiControls">
                <div class="control-group">
                    <label>é¡”æ–‡å­—ã‚’é¸æŠ:</label>
                    <div class="emoji-selector">
                        <button class="emoji-btn active" data-emoji="ğŸ˜Š">
                            <canvas width="30" height="30" style="border-radius: 50%;" data-type="smile"></canvas>
                        </button>
                        <button class="emoji-btn" data-emoji="ğŸ˜">
                            <canvas width="30" height="30" style="border-radius: 50%;" data-type="neutral"></canvas>
                        </button>
                        <button class="emoji-btn" data-emoji="ğŸ˜¢">
                            <canvas width="30" height="30" style="border-radius: 50%;" data-type="sad"></canvas>
                        </button>
                        <button class="emoji-btn" data-emoji="ğŸ˜®">
                            <canvas width="30" height="30" style="border-radius: 50%;" data-type="surprised"></canvas>
                        </button>
                    </div>
                </div>
                <div class="control-group">
                    <label>é¡”æ–‡å­—ã‚µã‚¤ã‚º: <span id="emojiSizeValue">40</span>px</label>
                    <input type="range" id="emojiSize" min="20" max="100" value="40">
                </div>
                <div class="control-group">
                    <label>é¡”æ–‡å­—ä¸é€æ˜åº¦: <span id="emojiOpacityValue">100</span>%</label>
                    <input type="range" id="emojiOpacity" min="10" max="100" value="100">
                </div>
                <button class="btn btn-secondary" id="adaptColorBtn">å‘¨è¾ºè‰²ã«åˆã‚ã›ã‚‹</button>
                <button class="btn btn-danger" id="deleteEmojiBtn">é¸æŠã—ãŸé¡”æ–‡å­—ã‚’å‰Šé™¤</button>
            </div>
            
            <div class="action-buttons">
                <button class="btn btn-secondary" id="undoBtn">å–ã‚Šæ¶ˆã— (Ctrl+Z)</button>
                <button class="btn btn-secondary" id="clearBrushBtn">ãƒ–ãƒ©ã‚·ã‚¯ãƒªã‚¢</button>
                <button class="btn btn-secondary" id="clearEmojiBtn">é¡”æ–‡å­—ã‚¯ãƒªã‚¢</button>
                <button class="btn btn-danger" id="clearPhotoBtn">å†™çœŸã‚¯ãƒªã‚¢</button>
                <button class="btn btn-primary" id="downloadBtn">ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰</button>
            </div>
        </div>
    </div>

    <script>
        class PhotoMaskingApp {
            constructor() {
                this.canvas = document.getElementById('canvas');
                this.ctx = this.canvas.getContext('2d');
                this.ctx.imageSmoothingEnabled = false;
                
                this.brushCanvas = document.createElement('canvas');
                this.brushCtx = this.brushCanvas.getContext('2d');
                this.brushCtx.imageSmoothingEnabled = false;
                
                this.emojiCanvas = document.createElement('canvas');
                this.emojiCtx = this.emojiCanvas.getContext('2d');
                this.emojiCtx.imageSmoothingEnabled = false;
                
                this.originalImage = null;
                this.isDrawing = false;
                this.currentMode = 'brush';
                this.selectedEmoji = 'ğŸ˜Š';
                this.brushColor = '#000000';
                this.brushSize = 20;
                this.opacity = 100;
                this.noise = 0;
                this.blur = 0;
                this.emojiSize = 40;
                this.emojiOpacity = 100;
                this.showBrushLayer = true;
                this.showEmojiLayer = true;
                
                this.emojis = [];
                this.selectedEmojiIndex = -1;
                this.isDragging = false;
                this.isResizing = false;
                this.isRotating = false;
                this.dragStart = { x: 0, y: 0 };
                
                this.history = [];
                this.historyStep = -1;
                
                this.initEventListeners();
                this.initEmojiUI();
            }
            
            initEventListeners() {
                // ãƒ•ã‚¡ã‚¤ãƒ«ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰
                const uploadArea = document.getElementById('uploadArea');
                const fileInput = document.getElementById('fileInput');
                
                uploadArea.addEventListener('click', () => fileInput.click());
                uploadArea.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    uploadArea.classList.add('dragover');
                });
                uploadArea.addEventListener('dragleave', () => {
                    uploadArea.classList.remove('dragover');
                });
                uploadArea.addEventListener('drop', (e) => {
                    e.preventDefault();
                    uploadArea.classList.remove('dragover');
                    const files = e.dataTransfer.files;
                    if (files.length > 0) {
                        this.loadImage(files[0]);
                    }
                });
                
                fileInput.addEventListener('change', (e) => {
                    if (e.target.files.length > 0) {
                        this.loadImage(e.target.files[0]);
                    }
                });
                
                // ãƒ¢ãƒ¼ãƒ‰åˆ‡ã‚Šæ›¿ãˆ
                document.getElementById('brushMode').addEventListener('click', () => this.setMode('brush'));
                document.getElementById('emojiMode').addEventListener('click', () => this.setMode('emoji'));
                
                // ãƒ¬ã‚¤ãƒ¤ãƒ¼è¡¨ç¤ºåˆ‡ã‚Šæ›¿ãˆ
                document.getElementById('brushLayerToggle').addEventListener('click', () => this.toggleBrushLayer());
                document.getElementById('emojiLayerToggle').addEventListener('click', () => this.toggleEmojiLayer());
                
                // ãƒ–ãƒ©ã‚·ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«
                document.getElementById('brushSize').addEventListener('input', (e) => {
                    this.brushSize = parseInt(e.target.value);
                    document.getElementById('brushSizeValue').textContent = this.brushSize;
                    this.updateBrushPreview();
                });
                
                document.getElementById('opacity').addEventListener('input', (e) => {
                    this.opacity = parseInt(e.target.value);
                    document.getElementById('opacityValue').textContent = this.opacity;
                    this.updateBrushPreview();
                });
                
                document.getElementById('noise').addEventListener('input', (e) => {
                    this.noise = parseInt(e.target.value);
                    document.getElementById('noiseValue').textContent = this.noise;
                });
                
                document.getElementById('blur').addEventListener('input', (e) => {
                    this.blur = parseInt(e.target.value);
                    document.getElementById('blurValue').textContent = this.blur;
                });
                
                // ã‚«ãƒ©ãƒ¼ãƒ‘ãƒ¬ãƒƒãƒˆ
                document.querySelectorAll('.color-btn').forEach(btn => {
                    btn.addEventListener('click', () => {
                        document.querySelectorAll('.color-btn').forEach(b => b.classList.remove('active'));
                        btn.classList.add('active');
                        this.brushColor = btn.dataset.color;
                        this.updateBrushPreview();
                    });
                });
                
                // é¡”æ–‡å­—ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«
                document.querySelectorAll('.emoji-btn').forEach(btn => {
                    btn.addEventListener('click', () => {
                        document.querySelectorAll('.emoji-btn').forEach(b => b.classList.remove('active'));
                        btn.classList.add('active');
                        this.selectedEmoji = btn.dataset.emoji;
                    });
                });
                
                document.getElementById('emojiSize').addEventListener('input', (e) => {
                    this.emojiSize = parseInt(e.target.value);
                    document.getElementById('emojiSizeValue').textContent = this.emojiSize;
                });
                
                document.getElementById('emojiOpacity').addEventListener('input', (e) => {
                    this.emojiOpacity = parseInt(e.target.value);
                    document.getElementById('emojiOpacityValue').textContent = this.emojiOpacity;
                });
                
                document.getElementById('adaptColorBtn').addEventListener('click', () => this.adaptEmojiColor());
                document.getElementById('deleteEmojiBtn').addEventListener('click', () => this.deleteSelectedEmoji());
                
                // ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ãƒœã‚¿ãƒ³
                document.getElementById('undoBtn').addEventListener('click', () => this.undo());
                document.getElementById('clearBrushBtn').addEventListener('click', () => this.clearBrush());
                document.getElementById('clearEmojiBtn').addEventListener('click', () => this.clearEmoji());
                document.getElementById('clearPhotoBtn').addEventListener('click', () => this.clearPhoto());
                document.getElementById('downloadBtn').addEventListener('click', () => this.download());
                
                // ã‚­ãƒ£ãƒ³ãƒã‚¹ã‚¤ãƒ™ãƒ³ãƒˆ
                this.canvas.addEventListener('mousedown', (e) => this.handleMouseDown(e));
                this.canvas.addEventListener('mousemove', (e) => this.handleMouseMove(e));
                this.canvas.addEventListener('mouseup', () => this.handleMouseUp());
                this.canvas.addEventListener('touchstart', (e) => this.handleTouchStart(e));
                this.canvas.addEventListener('touchmove', (e) => this.handleTouchMove(e));
                this.canvas.addEventListener('touchend', () => this.handleTouchEnd());
                
                // ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰ã‚·ãƒ§ãƒ¼ãƒˆã‚«ãƒƒãƒˆ
                document.addEventListener('keydown', (e) => {
                    if ((e.ctrlKey || e.metaKey) && e.key === 'z') {
                        e.preventDefault();
                        this.undo();
                    }
                });
                
                this.updateBrushPreview();
            }
            
            loadImage(file) {
                const reader = new FileReader();
                reader.onload = (e) => {
                    const img = new Image();
                    img.onload = () => {
                        this.originalImage = img;
                        this.setupCanvas();
                        this.saveState();
                        document.getElementById('canvas-container').style.display = 'block';
                        document.getElementById('controls').style.display = 'block';
                    };
                    img.src = e.target.result;
                };
                reader.readAsDataURL(file);
            }
            
            setupCanvas() {
                const maxWidth = 800;
                const maxHeight = 600;
                let { width, height } = this.originalImage;
                
                if (width > maxWidth || height > maxHeight) {
                    const ratio = Math.min(maxWidth / width, maxHeight / height);
                    width *= ratio;
                    height *= ratio;
                }
                
                this.canvas.width = width;
                this.canvas.height = height;
                this.brushCanvas.width = width;
                this.brushCanvas.height = height;
                this.emojiCanvas.width = width;
                this.emojiCanvas.height = height;
                
                this.redraw();
            }
            
            redraw() {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                
                // å…ƒç”»åƒã‚’æç”»
                this.ctx.drawImage(this.originalImage, 0, 0, this.canvas.width, this.canvas.height);
                
                // ãƒ–ãƒ©ã‚·ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’æç”»
                if (this.showBrushLayer) {
                    this.ctx.drawImage(this.brushCanvas, 0, 0);
                }
                
                // é¡”æ–‡å­—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’æç”»
                if (this.showEmojiLayer) {
                    this.drawEmojis();
                }
                
                // ç½²åã‚’æç”»
                this.drawSignature();
            }
            
            drawSignature() {
                this.ctx.save();
                this.ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
                this.ctx.font = '6px Arial';
                this.ctx.textAlign = 'right';
                this.ctx.textBaseline = 'bottom';
                this.ctx.fillText('SnapStranger', 
                    this.canvas.width - 10, this.canvas.height - 10);
                this.ctx.restore();
            }
            
            drawEmojis() {
                this.emojis.forEach((emoji, index) => {
                    this.ctx.save();
                    this.ctx.globalAlpha = emoji.opacity / 100;
                    this.ctx.translate(emoji.x, emoji.y);
                    this.ctx.rotate(emoji.rotation);
                    
                    // é¡”ã®å††ã‚’æç”»
                    this.ctx.fillStyle = emoji.color;
                    this.ctx.beginPath();
                    this.ctx.arc(0, 0, emoji.size / 2, 0, Math.PI * 2);
                    this.ctx.fill();
                    
                    // ç›®ã¨å£ã‚’æç”»
                    this.ctx.fillStyle = '#000000';
                    const eyeSize = emoji.size * 0.08;
                    const eyeOffset = emoji.size * 0.15;
                    const mouthWidth = emoji.size * 0.3;
                    const mouthHeight = emoji.size * 0.05;
                    const mouthY = emoji.size * 0.1;
                    
                    // å·¦ç›®
                    this.ctx.beginPath();
                    this.ctx.arc(-eyeOffset, -eyeOffset, eyeSize, 0, Math.PI * 2);
                    this.ctx.fill();
                    
                    // å³ç›®
                    this.ctx.beginPath();
                    this.ctx.arc(eyeOffset, -eyeOffset, eyeSize, 0, Math.PI * 2);
                    this.ctx.fill();
                    
                    // å£ï¼ˆè¡¨æƒ…ã«å¿œã˜ã¦å¤‰æ›´ï¼‰
                    if (emoji.text === 'ğŸ˜Š') {
                        // ç¬‘é¡” - å¼§ã‚’æã
                        this.ctx.beginPath();
                        this.ctx.arc(0, mouthY * 0.5, mouthWidth / 2, 0, Math.PI);
                        this.ctx.lineWidth = mouthHeight;
                        this.ctx.stroke();
                    } else if (emoji.text === 'ğŸ˜¢') {
                        // æ‚²ã—ã„é¡” - é€†å¼§ã‚’æã
                        this.ctx.beginPath();
                        this.ctx.arc(0, mouthY * 1.5, mouthWidth / 2, Math.PI, 0);
                        this.ctx.lineWidth = mouthHeight;
                        this.ctx.stroke();
                    } else if (emoji.text === 'ğŸ˜®') {
                        // é©šã„ãŸé¡” - å°ã•ã„å††
                        this.ctx.beginPath();
                        this.ctx.arc(0, mouthY, mouthWidth / 4, 0, Math.PI * 2);
                        this.ctx.fill();
                    } else {
                        // ç„¡è¡¨æƒ… - ç›´ç·š
                        this.ctx.fillRect(-mouthWidth / 2, mouthY - mouthHeight / 2, mouthWidth, mouthHeight);
                    }
                    
                    this.ctx.restore();
                    
                    // é¸æŠã•ã‚Œã¦ã„ã‚‹é¡”æ–‡å­—ã®ãƒãƒ³ãƒ‰ãƒ«ã‚’æç”»
                    if (index === this.selectedEmojiIndex) {
                        this.drawEmojiHandles(emoji);
                    }
                });
            }
            
            drawEmojiHandles(emoji) {
                const handleSize = 8;
                const distance = emoji.size / 2 + 10;
                
                this.ctx.save();
                this.ctx.translate(emoji.x, emoji.y);
                this.ctx.rotate(emoji.rotation);
                
                // ãƒªã‚µã‚¤ã‚ºãƒãƒ³ãƒ‰ãƒ«ï¼ˆç·‘ï¼‰
                this.ctx.fillStyle = '#28a745';
                this.ctx.fillRect(distance - handleSize/2, distance - handleSize/2, handleSize, handleSize);
                
                // å›è»¢ãƒãƒ³ãƒ‰ãƒ«ï¼ˆã‚ªãƒ¬ãƒ³ã‚¸ï¼‰
                this.ctx.fillStyle = '#ffc107';
                this.ctx.fillRect(distance - handleSize/2, -distance - handleSize/2, handleSize, handleSize);
                
                // å‰Šé™¤ãƒãƒ³ãƒ‰ãƒ«ï¼ˆèµ¤ï¼‰
                this.ctx.fillStyle = '#dc3545';
                this.ctx.fillRect(-distance - handleSize/2, -distance - handleSize/2, handleSize, handleSize);
                this.ctx.fillStyle = 'white';
                this.ctx.font = '6px Arial';
                this.ctx.textAlign = 'center';
                this.ctx.textBaseline = 'middle';
                this.ctx.fillText('Ã—', -distance, -distance);
                
                this.ctx.restore();
            }
            
            setMode(mode) {
                this.currentMode = mode;
                document.querySelectorAll('.mode-btn').forEach(btn => btn.classList.remove('active'));
                document.getElementById(mode + 'Mode').classList.add('active');
                
                if (mode === 'brush') {
                    document.getElementById('brushControls').style.display = 'block';
                    document.getElementById('emojiControls').style.display = 'none';
                    this.canvas.style.cursor = 'crosshair';
                } else {
                    document.getElementById('brushControls').style.display = 'none';
                    document.getElementById('emojiControls').style.display = 'block';
                    this.canvas.style.cursor = 'copy';
                }
                
                this.selectedEmojiIndex = -1;
                this.redraw();
            }
            
            toggleBrushLayer() {
                this.showBrushLayer = !this.showBrushLayer;
                const btn = document.getElementById('brushLayerToggle');
                if (this.showBrushLayer) {
                    btn.classList.add('active');
                    btn.textContent = 'ãƒ–ãƒ©ã‚·ãƒ¬ã‚¤ãƒ¤ãƒ¼è¡¨ç¤º';
                } else {
                    btn.classList.remove('active');
                    btn.textContent = 'ãƒ–ãƒ©ã‚·ãƒ¬ã‚¤ãƒ¤ãƒ¼éè¡¨ç¤º';
                }
                this.redraw();
            }
            
            toggleEmojiLayer() {
                this.showEmojiLayer = !this.showEmojiLayer;
                const btn = document.getElementById('emojiLayerToggle');
                if (this.showEmojiLayer) {
                    btn.classList.add('active');
                    btn.textContent = 'é¡”æ–‡å­—ãƒ¬ã‚¤ãƒ¤ãƒ¼è¡¨ç¤º';
                } else {
                    btn.classList.remove('active');
                    btn.textContent = 'é¡”æ–‡å­—ãƒ¬ã‚¤ãƒ¤ãƒ¼éè¡¨ç¤º';
                }
                this.redraw();
            }
            
            updateBrushPreview() {
                const preview = document.getElementById('brushPreview');
                const size = Math.min(this.brushSize, 50);
                preview.style.width = size + 'px';
                preview.style.height = size + 'px';
                preview.style.backgroundColor = this.brushColor;
                preview.style.opacity = this.opacity / 100;
            }
            
            getMousePos(e) {
                const rect = this.canvas.getBoundingClientRect();
                const scaleX = this.canvas.width / rect.width;
                const scaleY = this.canvas.height / rect.height;
                return {
                    x: (e.clientX - rect.left) * scaleX,
                    y: (e.clientY - rect.top) * scaleY
                };
            }
            
            getTouchPos(e) {
                const rect = this.canvas.getBoundingClientRect();
                const scaleX = this.canvas.width / rect.width;
                const scaleY = this.canvas.height / rect.height;
                return {
                    x: (e.touches[0].clientX - rect.left) * scaleX,
                    y: (e.touches[0].clientY - rect.top) * scaleY
                };
            }
            
            handleMouseDown(e) {
                const pos = this.getMousePos(e);
                
                if (this.currentMode === 'brush') {
                    this.isDrawing = true;
                    this.draw(pos.x, pos.y);
                } else if (this.currentMode === 'emoji') {
                    this.handleEmojiInteraction(pos.x, pos.y, e);
                }
            }
            
            handleMouseMove(e) {
                const pos = this.getMousePos(e);
                
                if (this.currentMode === 'brush' && this.isDrawing) {
                    this.draw(pos.x, pos.y);
                } else if (this.currentMode === 'emoji') {
                    this.handleEmojiDrag(pos.x, pos.y);
                }
            }
            
            handleMouseUp() {
                if (this.isDrawing) {
                    this.isDrawing = false;
                    this.saveState();
                }
                this.isDragging = false;
                this.isResizing = false;
                this.isRotating = false;
                
                // ã‚«ãƒ¼ã‚½ãƒ«ã‚’å…ƒã®ãƒ¢ãƒ¼ãƒ‰ã«æˆ»ã™
                if (this.currentMode === 'brush') {
                    this.canvas.style.cursor = 'crosshair';
                } else {
                    this.canvas.style.cursor = 'copy';
                }
            }
            
            handleTouchStart(e) {
                e.preventDefault();
                const pos = this.getTouchPos(e);
                
                if (this.currentMode === 'brush') {
                    this.isDrawing = true;
                    this.draw(pos.x, pos.y);
                } else if (this.currentMode === 'emoji') {
                    this.handleEmojiInteraction(pos.x, pos.y, e);
                }
            }
            
            handleTouchMove(e) {
                e.preventDefault();
                const pos = this.getTouchPos(e);
                
                if (this.currentMode === 'brush' && this.isDrawing) {
                    this.draw(pos.x, pos.y);
                } else if (this.currentMode === 'emoji') {
                    this.handleEmojiDrag(pos.x, pos.y);
                }
            }
            
            handleTouchEnd() {
                if (this.isDrawing) {
                    this.isDrawing = false;
                    this.saveState();
                }
                this.isDragging = false;
                this.isResizing = false;
                this.isRotating = false;
                
                // ã‚«ãƒ¼ã‚½ãƒ«ã‚’å…ƒã®ãƒ¢ãƒ¼ãƒ‰ã«æˆ»ã™
                if (this.currentMode === 'brush') {
                    this.canvas.style.cursor = 'crosshair';
                } else {
                    this.canvas.style.cursor = 'copy';
                }
            }
            
            draw(x, y) {
                this.brushCtx.save();
                this.brushCtx.globalAlpha = this.opacity / 100;
                this.brushCtx.fillStyle = this.brushColor;
                
                if (this.blur > 0) {
                    this.brushCtx.filter = `blur(${this.blur}px)`;
                }
                
                let size = this.brushSize;
                if (this.noise > 0) {
                    size += (Math.random() - 0.5) * (this.noise / 100) * this.brushSize;
                }
                
                this.brushCtx.beginPath();
                this.brushCtx.arc(x, y, size / 2, 0, Math.PI * 2);
                this.brushCtx.fill();
                this.brushCtx.restore();
                
                this.redraw();
            }
            
            handleEmojiInteraction(x, y, e) {
                // ãƒãƒ³ãƒ‰ãƒ«ã®ã‚¯ãƒªãƒƒã‚¯åˆ¤å®š
                if (this.selectedEmojiIndex >= 0) {
                    const emoji = this.emojis[this.selectedEmojiIndex];
                    const handleSize = 8;
                    const distance = emoji.size / 2 + 10;
                    
                    // åº§æ¨™å¤‰æ›
                    const dx = x - emoji.x;
                    const dy = y - emoji.y;
                    const cos = Math.cos(-emoji.rotation);
                    const sin = Math.sin(-emoji.rotation);
                    const rotatedX = dx * cos - dy * sin;
                    const rotatedY = dx * sin + dy * cos;
                    
                    // å‰Šé™¤ãƒãƒ³ãƒ‰ãƒ«
                    if (Math.abs(rotatedX + distance) < handleSize && Math.abs(rotatedY + distance) < handleSize) {
                        this.emojis.splice(this.selectedEmojiIndex, 1);
                        this.selectedEmojiIndex = -1;
                        this.redraw();
                        this.saveState();
                        return;
                    }
                    
                    // ãƒªã‚µã‚¤ã‚ºãƒãƒ³ãƒ‰ãƒ«
                    if (Math.abs(rotatedX - distance) < handleSize && Math.abs(rotatedY - distance) < handleSize) {
                        this.isResizing = true;
                        this.canvas.style.cursor = 'se-resize';
                        this.dragStart = { x, y };
                        return;
                    }
                    
                    // å›è»¢ãƒãƒ³ãƒ‰ãƒ«
                    if (Math.abs(rotatedX - distance) < handleSize && Math.abs(rotatedY + distance) < handleSize) {
                        this.isRotating = true;
                        this.canvas.style.cursor = 'grab';
                        this.dragStart = { x, y };
                        return;
                    }
                }
                
                // é¡”æ–‡å­—ã®é¸æŠåˆ¤å®š
                for (let i = this.emojis.length - 1; i >= 0; i--) {
                    const emoji = this.emojis[i];
                    const distance = Math.sqrt((x - emoji.x) ** 2 + (y - emoji.y) ** 2);
                    if (distance < emoji.size / 2) {
                        this.selectedEmojiIndex = i;
                        this.isDragging = true;
                        this.canvas.style.cursor = 'move';
                        this.dragStart = { x: x - emoji.x, y: y - emoji.y };
                        
                        // é¸æŠã—ãŸé¡”æ–‡å­—ã®ç¨®é¡ã‚’UIã«åæ˜ 
                        this.selectedEmoji = emoji.text;
                        this.updateEmojiUISelection();
                        
                        this.redraw();
                        return;
                    }
                }
                
                // æ–°ã—ã„é¡”æ–‡å­—ã‚’è¿½åŠ 
                this.selectedEmojiIndex = -1;
                const newEmoji = {
                    text: this.selectedEmoji,
                    x: x,
                    y: y,
                    size: this.emojiSize,
                    opacity: this.emojiOpacity,
                    rotation: 0,
                    color: '#ffdd44'
                };
                this.emojis.push(newEmoji);
                this.selectedEmojiIndex = this.emojis.length - 1;
                this.redraw();
                this.saveState();
            }
            
            handleEmojiDrag(x, y) {
                if (this.selectedEmojiIndex < 0) return;
                
                const emoji = this.emojis[this.selectedEmojiIndex];
                
                if (this.isDragging) {
                    emoji.x = x - this.dragStart.x;
                    emoji.y = y - this.dragStart.y;
                    this.redraw();
                } else if (this.isResizing) {
                    const distance = Math.sqrt((x - emoji.x) ** 2 + (y - emoji.y) ** 2);
                    emoji.size = Math.max(20, Math.min(100, distance * 2));
                    this.redraw();
                } else if (this.isRotating) {
                    const angle = Math.atan2(y - emoji.y, x - emoji.x);
                    emoji.rotation = angle;
                    this.redraw();
                }
            }
            
            adaptEmojiColor() {
                if (this.selectedEmojiIndex < 0) {
                    alert('é¡”æ–‡å­—ã‚’é¸æŠã—ã¦ãã ã•ã„');
                    return;
                }
                
                if (!this.originalImage) {
                    alert('ç”»åƒãŒèª­ã¿è¾¼ã¾ã‚Œã¦ã„ã¾ã›ã‚“');
                    return;
                }
                
                const emoji = this.emojis[this.selectedEmojiIndex];
                
                // å…ƒã®ç”»åƒã‚’ä¸€æ™‚çš„ãªã‚­ãƒ£ãƒ³ãƒã‚¹ã«æç”»
                const tempCanvas = document.createElement('canvas');
                const tempCtx = tempCanvas.getContext('2d');
                tempCanvas.width = this.canvas.width;
                tempCanvas.height = this.canvas.height;
                tempCtx.drawImage(this.originalImage, 0, 0, tempCanvas.width, tempCanvas.height);
                
                // é¡”æ–‡å­—ã®å‘¨è¾ºé ˜åŸŸã‚’ã‚ˆã‚Šåºƒãã‚µãƒ³ãƒ—ãƒªãƒ³ã‚°
                const sampleRadius = Math.max(emoji.size, 30); // æœ€å°30pxã€é¡”æ–‡å­—ã‚µã‚¤ã‚ºä»¥ä¸Š
                const sampleSize = sampleRadius * 2;
                
                // å¢ƒç•Œãƒã‚§ãƒƒã‚¯
                const startX = Math.max(0, emoji.x - sampleRadius);
                const startY = Math.max(0, emoji.y - sampleRadius);
                const endX = Math.min(tempCanvas.width, emoji.x + sampleRadius);
                const endY = Math.min(tempCanvas.height, emoji.y + sampleRadius);
                
                const width = endX - startX;
                const height = endY - startY;
                
                if (width <= 0 || height <= 0) {
                    alert('ã‚µãƒ³ãƒ—ãƒªãƒ³ã‚°é ˜åŸŸãŒç„¡åŠ¹ã§ã™');
                    return;
                }
                
                // å…ƒã®ç”»åƒã‹ã‚‰è‰²ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—
                const imageData = tempCtx.getImageData(startX, startY, width, height);
                const data = imageData.data;
                
                let r = 0, g = 0, b = 0, count = 0;
                
                // é¡”æ–‡å­—ã®ä¸­å¿ƒéƒ¨åˆ†ã‚’é™¤å¤–ã—ã¦ã‚µãƒ³ãƒ—ãƒªãƒ³ã‚°
                const centerX = emoji.x - startX;
                const centerY = emoji.y - startY;
                const excludeRadius = emoji.size / 2;
                
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        // é¡”æ–‡å­—ã®ä¸­å¿ƒéƒ¨åˆ†ã‚’ã‚¹ã‚­ãƒƒãƒ—
                        const distanceFromCenter = Math.sqrt((x - centerX) ** 2 + (y - centerY) ** 2);
                        if (distanceFromCenter < excludeRadius) {
                            continue;
                        }
                        
                        const index = (y * width + x) * 4;
                        const alpha = data[index + 3];
                        
                        // é€æ˜ã§ãªã„ãƒ”ã‚¯ã‚»ãƒ«ã®ã¿ã‚’è¨ˆç®—ã«å«ã‚ã‚‹
                        if (alpha > 0) {
                            r += data[index];
                            g += data[index + 1];
                            b += data[index + 2];
                            count++;
                        }
                    }
                }
                
                if (count === 0) {
                    alert('å‘¨è¾ºè‰²ã‚’æ¤œå‡ºã§ãã¾ã›ã‚“ã§ã—ãŸ');
                    return;
                }
                
                // å¹³å‡è‰²ã‚’è¨ˆç®—
                r = Math.floor(r / count);
                g = Math.floor(g / count);
                b = Math.floor(b / count);
                
                // å‘¨è¾ºè‰²70% + é»„è‰²30%ã§æ··åˆ
                const defaultYellow = { r: 255, g: 255, b: 0 };
                const ambientRatio = 0.7; // å‘¨è¾ºè‰²ã®æ¯”ç‡
                const yellowRatio = 0.3;  // é»„è‰²ã®æ¯”ç‡
                
                const finalR = Math.floor(r * ambientRatio + defaultYellow.r * yellowRatio);
                const finalG = Math.floor(g * ambientRatio + defaultYellow.g * yellowRatio);
                const finalB = Math.floor(b * ambientRatio + defaultYellow.b * yellowRatio);
                
                // é¡”æ–‡å­—ã®è‰²ã‚’æ›´æ–°
                emoji.color = `rgb(${finalR}, ${finalG}, ${finalB})`;
                this.redraw();
                this.saveState();
                alert(`é¡”æ–‡å­—ã®è‰²ã‚’å‘¨è¾ºè‰²ã«åˆã‚ã›ã¾ã—ãŸ (å‘¨è¾ºè‰²70% + é»„è‰²30%: RGB ${finalR}, ${finalG}, ${finalB})`);
            }
            
            saveState() {
                this.historyStep++;
                if (this.historyStep < this.history.length) {
                    this.history.length = this.historyStep;
                }
                
                const state = {
                    brushData: this.brushCtx.getImageData(0, 0, this.brushCanvas.width, this.brushCanvas.height),
                    emojis: JSON.parse(JSON.stringify(this.emojis))
                };
                this.history.push(state);
                
                if (this.history.length > 50) {
                    this.history.shift();
                    this.historyStep--;
                }
            }
            
            undo() {
                if (this.historyStep > 0) {
                    this.historyStep--;
                    const state = this.history[this.historyStep];
                    this.brushCtx.putImageData(state.brushData, 0, 0);
                    this.emojis = JSON.parse(JSON.stringify(state.emojis));
                    this.selectedEmojiIndex = -1;
                    this.redraw();
                }
            }
            
            clearBrush() {
                this.brushCtx.clearRect(0, 0, this.brushCanvas.width, this.brushCanvas.height);
                this.redraw();
                this.saveState();
            }
            
            clearEmoji() {
                this.emojis = [];
                this.selectedEmojiIndex = -1;
                this.redraw();
                this.saveState();
            }
            
            clearPhoto() {
                this.originalImage = null;
                this.emojis = [];
                this.selectedEmojiIndex = -1;
                this.history = [];
                this.historyStep = -1;
                this.brushCtx.clearRect(0, 0, this.brushCanvas.width, this.brushCanvas.height);
                document.getElementById('canvas-container').style.display = 'none';
                document.getElementById('controls').style.display = 'none';
            }
            
            download() {
                const downloadCanvas = document.createElement('canvas');
                const downloadCtx = downloadCanvas.getContext('2d');
                downloadCtx.imageSmoothingEnabled = false;
                
                downloadCanvas.width = this.originalImage.width;
                downloadCanvas.height = this.originalImage.height;
                
                // å…ƒç”»åƒã‚’æç”»
                downloadCtx.drawImage(this.originalImage, 0, 0);
                
                // ãƒ–ãƒ©ã‚·ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’æç”»
                if (this.showBrushLayer) {
                    const scaleX = this.originalImage.width / this.canvas.width;
                    const scaleY = this.originalImage.height / this.canvas.height;
                    downloadCtx.drawImage(this.brushCanvas, 0, 0, 
                        this.originalImage.width, this.originalImage.height);
                }
                
                // é¡”æ–‡å­—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’æç”»
                if (this.showEmojiLayer) {
                    const scaleX = this.originalImage.width / this.canvas.width;
                    const scaleY = this.originalImage.height / this.canvas.height;
                    
                    this.emojis.forEach(emoji => {
                        downloadCtx.save();
                        downloadCtx.globalAlpha = emoji.opacity / 100;
                        downloadCtx.translate(emoji.x * scaleX, emoji.y * scaleY);
                        downloadCtx.rotate(emoji.rotation);
                        
                        const scaledSize = emoji.size * scaleX;
                        
                        // é¡”ã®å††ã‚’æç”»
                        downloadCtx.fillStyle = emoji.color;
                        downloadCtx.beginPath();
                        downloadCtx.arc(0, 0, scaledSize / 2, 0, Math.PI * 2);
                        downloadCtx.fill();
                        
                        // ç›®ã¨å£ã‚’æç”»
                        downloadCtx.fillStyle = '#000000';
                        const eyeSize = scaledSize * 0.08;
                        const eyeOffset = scaledSize * 0.15;
                        const mouthWidth = scaledSize * 0.3;
                        const mouthHeight = scaledSize * 0.05;
                        const mouthY = scaledSize * 0.1;
                        
                        // å·¦ç›®
                        downloadCtx.beginPath();
                        downloadCtx.arc(-eyeOffset, -eyeOffset, eyeSize, 0, Math.PI * 2);
                        downloadCtx.fill();
                        
                        // å³ç›®
                        downloadCtx.beginPath();
                        downloadCtx.arc(eyeOffset, -eyeOffset, eyeSize, 0, Math.PI * 2);
                        downloadCtx.fill();
                        
                        // å£ï¼ˆè¡¨æƒ…ã«å¿œã˜ã¦å¤‰æ›´ï¼‰
                        if (emoji.text === 'ğŸ˜Š') {
                            // ç¬‘é¡” - å¼§ã‚’æã
                            downloadCtx.beginPath();
                            downloadCtx.arc(0, mouthY * 0.5, mouthWidth / 2, 0, Math.PI);
                            downloadCtx.lineWidth = mouthHeight;
                            downloadCtx.stroke();
                        } else if (emoji.text === 'ğŸ˜¢') {
                            // æ‚²ã—ã„é¡” - é€†å¼§ã‚’æã
                            downloadCtx.beginPath();
                            downloadCtx.arc(0, mouthY * 1.5, mouthWidth / 2, Math.PI, 0);
                            downloadCtx.lineWidth = mouthHeight;
                            downloadCtx.stroke();
                        } else if (emoji.text === 'ğŸ˜®') {
                            // é©šã„ãŸé¡” - å°ã•ã„å††
                            downloadCtx.beginPath();
                            downloadCtx.arc(0, mouthY, mouthWidth / 4, 0, Math.PI * 2);
                            downloadCtx.fill();
                        } else {
                            // ç„¡è¡¨æƒ… - ç›´ç·š
                            downloadCtx.fillRect(-mouthWidth / 2, mouthY - mouthHeight / 2, mouthWidth, mouthHeight);
                        }
                        
                        downloadCtx.restore();
                    });
                }
                
                // ç½²åã‚’æç”»
                downloadCtx.save();
                downloadCtx.fillStyle = 'rgba(0, 0, 0, 0.8)';
                downloadCtx.font = `${Math.max(6, downloadCanvas.width / 100)}px Arial`;
                downloadCtx.textAlign = 'right';
                downloadCtx.textBaseline = 'bottom';
                downloadCtx.fillText('SnapStranger', 
                    downloadCanvas.width - 20, downloadCanvas.height - 20);
                downloadCtx.restore();
                
                // ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰
                downloadCanvas.toBlob((blob) => {
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `masked-photo-${Date.now()}.jpg`;
                    a.click();
                    URL.revokeObjectURL(url);
                }, 'image/jpeg', 1.0);
            }
            
            initEmojiUI() {
                // é¡”æ–‡å­—é¸æŠUIã®ã‚­ãƒ£ãƒ³ãƒã‚¹ã«å®Ÿéš›ã®é¡”æ–‡å­—ã‚’æç”»
                const emojiButtons = document.querySelectorAll('.emoji-btn canvas');
                emojiButtons.forEach((canvas, index) => {
                    const ctx = canvas.getContext('2d');
                    const type = canvas.getAttribute('data-type');
                    this.drawEmojiPreview(ctx, type, 15, 15, 12, '#ffdd44');
                });
                
                // é¡”æ–‡å­—é¸æŠãƒœã‚¿ãƒ³ã®ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ã‚’è¨­å®š
                document.querySelectorAll('.emoji-btn').forEach((btn, index) => {
                    btn.addEventListener('click', () => {
                        const emoji = btn.getAttribute('data-emoji');
                        this.selectedEmoji = emoji;
                        this.updateEmojiUISelection();
                    });
                });
            }
            
            drawEmojiPreview(ctx, type, x, y, size, color) {
                ctx.save();
                ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
                
                // é¡”ã®å††ã‚’æç”»
                ctx.fillStyle = color;
                ctx.beginPath();
                ctx.arc(x, y, size, 0, Math.PI * 2);
                ctx.fill();
                
                // ç›®ã‚’æç”»
                ctx.fillStyle = '#000000';
                const eyeSize = size * 0.15;
                const eyeOffset = size * 0.3;
                ctx.beginPath();
                ctx.arc(x - eyeOffset, y - eyeOffset * 0.5, eyeSize, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.arc(x + eyeOffset, y - eyeOffset * 0.5, eyeSize, 0, Math.PI * 2);
                ctx.fill();
                
                // å£ã‚’æç”»
                const mouthY = y + size * 0.3;
                const mouthWidth = size * 0.6;
                const mouthHeight = size * 0.1;
                
                if (type === 'smile') {
                    // ç¬‘é¡” - å¼§ã‚’æã
                    ctx.beginPath();
                    ctx.arc(x, mouthY - size * 0.2, mouthWidth / 2, 0, Math.PI);
                    ctx.lineWidth = mouthHeight;
                    ctx.stroke();
                } else if (type === 'sad') {
                    // æ‚²ã—ã„é¡” - é€†å¼§ã‚’æã
                    ctx.beginPath();
                    ctx.arc(x, mouthY + size * 0.2, mouthWidth / 2, Math.PI, 0);
                    ctx.lineWidth = mouthHeight;
                    ctx.stroke();
                } else if (type === 'surprised') {
                    // é©šã„ãŸé¡” - å°ã•ã„å††
                    ctx.beginPath();
                    ctx.arc(x, mouthY, mouthWidth / 4, 0, Math.PI * 2);
                    ctx.fill();
                } else {
                    // ç„¡è¡¨æƒ… - ç›´ç·š
                    ctx.fillRect(x - mouthWidth / 2, mouthY - mouthHeight / 2, mouthWidth, mouthHeight);
                }
                
                ctx.restore();
            }
            
            updateEmojiUISelection() {
                // é¡”æ–‡å­—é¸æŠãƒœã‚¿ãƒ³ã®çŠ¶æ…‹ã‚’æ›´æ–°
                document.querySelectorAll('.emoji-btn').forEach(btn => {
                    btn.classList.remove('active');
                    if (btn.getAttribute('data-emoji') === this.selectedEmoji) {
                        btn.classList.add('active');
                    }
                });
            }
            
            deleteSelectedEmoji() {
                if (this.selectedEmojiIndex >= 0) {
                    this.emojis.splice(this.selectedEmojiIndex, 1);
                    this.selectedEmojiIndex = -1;
                    this.redraw();
                    this.saveState();
                } else {
                    alert('å‰Šé™¤ã™ã‚‹é¡”æ–‡å­—ã‚’é¸æŠã—ã¦ãã ã•ã„');
                }
            }
        }
        
        // ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³åˆæœŸåŒ–
        document.addEventListener('DOMContentLoaded', () => {
            new PhotoMaskingApp();
        });
    </script>
</body>
</html>

